<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aerosol Classifier Operational Range Calculator</title>
    
    <!-- MathJax Configuration -->
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_SVG"></script>
    <script type="text/javascript">
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['$$','$$']],
                displayMath: [['\\[','\\]']],
                processEscapes: true
            }
        });
    </script>
    
    <!-- Other Dependencies -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
    <link rel="stylesheet" href="styles.css">
    <style>
        .card {
            margin: 20px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .plot-container {
            height: 600px;
            width: 100%;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- AAC Section -->
        <div class="card">
            <div class="card-header">
                <h2>AAC Operational Range Calculator</h2>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-4">
                        <div class="form-group mb-3">
                            <label for="aac-qa">Aerosol Flow Rate ($$Q_{\mathrm{a}}$$) [L/min]:</label>
                            <input type="number" class="form-control" id="aac-qa" value="0.3" min="0.1" max="10" step="0.1">
                        </div>
                        <div class="form-group mb-3">
                            <label for="aac-qsh">Sheath Flow Rate ($$Q_{\mathrm{sh}}$$) [L/min]:</label>
                            <input type="number" class="form-control" id="aac-qsh" value="3" min="2" max="15" step="0.1">
                        </div>
                        <button class="btn btn-primary" onclick="calculateAAC()">Calculate</button>
                    </div>
                    <div class="col-md-8">
                        <div id="aac-plot" class="plot-container"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        function Cc(d, P, T) {
            const alpha = 1.165 * 2;
            const beta = 0.483 * 2;
            const gamma = 0.997 / 2;
            const la = 67.30e-9;
            
            const lap = la * Math.pow(T / 296.15, 2) * (101325/P) * ((110.4 + 296.15) / (T + 110.4));
            
            return 1 + (lap / d) * (alpha + beta * Math.exp(-gamma * d / lap));
        }

        function bisectionMethod(func, a, b, tolerance = 1e-10, maxIterations = 100) {
            let fa = func(a);
            let fb = func(b);
            
            if (fa * fb > 0) {
                throw new Error('Initial points do not bracket the root');
            }
            
            for (let i = 0; i < maxIterations; i++) {
                let c = (a + b) / 2;
                let fc = func(c);
                
                if (Math.abs(fc) < tolerance) {
                    return c;
                }
                
                if (fa * fc < 0) {
                    b = c;
                    fb = fc;
                } else {
                    a = c;
                    fa = fc;
                }
            }
            
            return (a + b) / 2;
        }

        function formatScientific(num) {
            return num.toExponential(2);
        }

        function calculateAAC() {
            try {
                // Constants
                const P = 101325;
                const T = 298.15;
                const mu = 1.81809e-5 * Math.pow(T / 293.15, 1.5) * (293.15 + 110.4) / (T + 110.4);
                const Q_a = parseFloat(document.getElementById('aac-qa').value) / 60000;
                const Q_sh = parseFloat(document.getElementById('aac-qsh').value) / 60000;
                
                const Q_sh_lb = 2 / 60000;
                const Q_sh_ub = 15 / 60000;
                const Q_sh_RB = 10 / 60000;
                const r_1 = 56e-3;
                const r_2 = 60e-3;
                const L = 0.206;
                const w_lb_i = 2 * Math.PI / 60 * 200;
                const w_ub_i = 2 * Math.PI / 60 * 7000;

                // Create arrays
                const points = 100;
                const Q_sh_spa = Array.from({length: points}, (_, i) => 
                    Q_sh_lb + (Q_sh_ub - Q_sh_lb) * i / (points - 1));
                const R_t = Q_sh_spa.map(q => q / Q_a);
                const R_t_lb = Q_sh_lb / Q_a;
                const R_t_up = Q_sh_ub / Q_a;

                // Calculate w_up array
                const w_up = Q_sh_spa.map(Q => {
                    if (Q < Q_sh_RB) {
                        return Math.min(w_ub_i, 723.7 - 9.87 * 60000 * Q);
                    } else {
                        return Math.min(w_ub_i, 875 - 25 * 60000 * Q);
                    }
                });

                const w_low = Array(points).fill(w_lb_i);

                const factor1 = w_low.map(w => (36 * mu) / (Math.PI * 1000 * Math.pow(r_1 + r_2, 2) * L * Math.pow(w, 2)));
                const factor2 = w_up.map(w => (36 * mu) / (Math.PI * 1000 * Math.pow(r_1 + r_2, 2) * L * Math.pow(w, 2)));

                // Calculate d_min and d_max
                const d_min = Q_sh_spa.map((Q_sh_val, i) => {
                    const f = d => Math.pow(d, 2) * Cc(d, P, T) - (factor2[i] * Q_sh_val);
                    return bisectionMethod(f, 1e-9, 1e-7);
                });

                const d_max = Q_sh_spa.map((Q_sh_val, i) => {
                    const f = d => Math.pow(d, 2) * Cc(d, P, T) - (factor1[i] * Q_sh_val);
                    return bisectionMethod(f, 1e-7, 1e-5);
                });

                // Find index for current Q_sh
                const index = Q_sh_spa.findIndex(q => Math.abs(q - Q_sh) < 1e-10);
                
                // Calculate specific points
                const f1 = d => Math.pow(d, 2) * Cc(d, P, T) - (factor2[index] * Q_sh);
                const f2 = d => Math.pow(d, 2) * Cc(d, P, T) - (factor1[index] * Q_sh);
                
                const d_i = bisectionMethod(f1, 1e-9, 1e-7);
                const d_o = bisectionMethod(f2, 1e-7, 1e-5);

                const traces = [
                    {
                        x: d_min.map(d => d * 1e9),
                        y: R_t,
                        mode: 'lines',
                        line: { color: 'blue' },
                        showlegend: false
                    },
                    {
                        x: d_max.map(d => d * 1e9),
                        y: R_t,
                        mode: 'lines',
                        line: { color: 'blue' },
                        showlegend: false
                    },
                    {
                        x: [d_min[0] * 1e9, d_max[0] * 1e9],
                        y: [R_t_lb, R_t_lb],
                        mode: 'lines',
                        line: { color: 'blue' },
                        showlegend: false
                    },
                    {
                        x: [d_min[d_min.length-1] * 1e9, d_max[d_max.length-1] * 1e9],
                        y: [R_t_up, R_t_up],
                        mode: 'lines',
                        line: { color: 'blue' },
                        showlegend: false
                    },
                    {
                        x: [d_i * 1e9, d_o * 1e9],
                        y: [Q_sh / Q_a, Q_sh / Q_a],
                        mode: 'lines',
                        name: 'Selected Q_sh',
                        line: { color: 'red' }
                    }
                ];

                const layout = {
                    title: 'AAC Operational Range',
                    xaxis: {
                        title: 'Aerodynamic diameter, d_a (nm)',
                        type: 'log',
                        showgrid: true,
                        gridwidth: 1,
                        range: [1, 3]
                    },
                    yaxis: {
                        title: 'R_Ï„',
                        type: 'log',
                        showgrid: true,
                        gridwidth: 1,
                        range: [0, 2]
                    },
                    showlegend: true,
                    legend: {
                        x: 0.7,
                        y: 0.9,
                        xanchor: 'left',
                        yanchor: 'top'
                    },
                    width: 800,
                    height: 600,
                    margin: {
                        l: 80,
                        r: 50,
                        t: 50,
                        b: 80
                    }
                };

                const config = {
                    displayModeBar: true,
                    responsive: true
                };

                Plotly.newPlot('aac-plot', traces, layout, config);
                
            } catch (error) {
                console.error('Error in calculateAAC:', error);
                alert('An error occurred during calculation. Please check the console for details.');
            }
        }

        // Calculate initial plot when page loads
        document.addEventListener('DOMContentLoaded', calculateAAC);
    </script>
</body>
</html> 