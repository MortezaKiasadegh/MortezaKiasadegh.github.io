<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DMA Operational Range Calculator</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.js"></script>
    <link rel="stylesheet" href="styles.css">
    <style>
        .card {
            margin: 20px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        .plot-container {
            height: 600px;
            width: 100%;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="card">
            <div class="card-header">
                <h2>DMA Operational Range Calculator</h2>
            </div>
            <div class="card-body">
                <div class="row">
                    <div class="col-md-4">
                        <div class="form-group mb-3">
                            <label for="qa">Aerosol Flow Rate ($Q_{\mathrm{a}}$) [L/min]:</label>
                            <input type="number" class="form-control" id="qa" value="0.3" min="0.1" max="10" step="0.1">
                        </div>
                        <div class="form-group mb-3">
                            <label for="qsh">Sheath Flow Rate ($Q_{\mathrm{sh}}$) [L/min]:</label>
                            <input type="number" class="form-control" id="qsh" value="3" min="2" max="30" step="0.1">
                        </div>
                        <button class="btn btn-primary" onclick="calculateDMA()">Calculate</button>
                    </div>
                    <div class="col-md-8">
                        <div id="plot" class="plot-container"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script>
        // JavaScript code here to ensure everything is loaded
        function Cc(d, P, T) {
            try {
                const alpha = 1.165 * 2;
                const beta = 0.483 * 2;
                const gamma = 0.997 / 2;
                const la = 67.30e-9;
                
                const lap = la * Math.pow(T / 296.15, 2) * (101325/P) * ((110.4 + 296.15) / (T + 110.4));
                
                return 1 + (lap / d) * (alpha + beta * Math.exp(-gamma * d / lap));
            } catch (error) {
                console.error('Error in Cc:', error);
                throw error;
            }
        }

        function bisectionMethod(func, a, b, tolerance = 1e-10, maxIterations = 100) {
            try {
                let fa = func(a);
                let fb = func(b);
                
                if (fa * fb > 0) {
                    throw new Error('Initial points do not bracket the root');
                }
                
                for (let i = 0; i < maxIterations; i++) {
                    let c = (a + b) / 2;
                    let fc = func(c);
                    
                    if (Math.abs(fc) < tolerance) {
                        return c;
                    }
                    
                    if (fa * fc < 0) {
                        b = c;
                        fb = fc;
                    } else {
                        a = c;
                        fa = fc;
                    }
                }
                
                return (a + b) / 2;
            } catch (error) {
                console.error('Error in bisectionMethod:', error);
                throw error;
            }
        }

        function calculateDMA() {
            try {
                console.log('Starting DMA calculation...');
                
                // Constants
                const P = 101325;
                const T = 298.15;
                const mu = 1.81809e-5 * Math.pow(T / 293.15, 1.5) * (293.15 + 110.4) / (T + 110.4);
                const Q_a = parseFloat(document.getElementById('qa').value) / 60000;
                const Q_sh = parseFloat(document.getElementById('qsh').value) / 60000;
                
                console.log('Q_a:', Q_a);
                
                const Q_sh_lb = 2 / 60000;
                const Q_sh_ub = 30 / 60000;
                const r_1 = 9.37e-3;
                const r_2 = 19.61e-3;
                const L = 0.44369;
                const e = 1.6e-19;
                const V_min = 10;
                const V_max = 10000;

                const log_r_ratio = Math.log(r_2 / r_1);
                const factor1 = (2 * V_min * L * e) / (3 * mu * log_r_ratio);
                const factor2 = (2 * V_max * L * e) / (3 * mu * log_r_ratio);

                // Create arrays
                const points = 100;
                const Q_sh_spa = Array.from({length: points}, (_, i) => 
                    Q_sh_lb + (Q_sh_ub - Q_sh_lb) * i / (points - 1));
                const R_B = Q_sh_spa.map(q => q / Q_a);
                const R_B_lb = Q_sh_lb / Q_a;
                const R_B_up = Q_sh_ub / Q_a;

                console.log('Calculating d_min and d_max...');

                // Calculate d_min and d_max
                const d_min = Q_sh_spa.map(Q_sh_val => {
                    const f = d => d - (factor1 / Q_sh_val) * Cc(d, P, T);
                    return bisectionMethod(f, 1e-9, 1e-7);
                });

                const d_max = Q_sh_spa.map(Q_sh_val => {
                    const f = d => d - (factor2 / Q_sh_val) * Cc(d, P, T);
                    return bisectionMethod(f, 1e-7, 1e-5);
                });

                console.log('Plotting results...');

                // Calculate specific points for input Q_sh
                const f1 = d => d - (factor1 / Q_sh) * Cc(d, P, T);
                const f2 = d => d - (factor2 / Q_sh) * Cc(d, P, T);
                
                const d_i = bisectionMethod(f1, 1e-9, 1e-7);
                const d_o = bisectionMethod(f2, 1e-7, 1e-5);

                // Convert to nanometers
                const d_min_nm = d_min.map(d => d * 1e9);
                const d_max_nm = d_max.map(d => d * 1e9);

                // Create plot
                const traces = [
                    {
                        x: d_min_nm,
                        y: R_B,
                        mode: 'lines',
                        name: 'Lower bound',
                        line: { color: 'red' }
                    },
                    {
                        x: d_max_nm,
                        y: R_B,
                        mode: 'lines',
                        name: 'Upper bound',
                        line: { color: 'red' }
                    },
                    {
                        x: [d_min_nm[0], d_max_nm[0]],
                        y: [R_B_lb, R_B_lb],
                        mode: 'lines',
                        name: 'Lower R_B',
                        line: { color: 'red' }
                    },
                    {
                        x: [d_min_nm[d_min_nm.length-1], d_max_nm[d_max_nm.length-1]],
                        y: [R_B_up, R_B_up],
                        mode: 'lines',
                        name: 'Upper R_B',
                        line: { color: 'red' }
                    },
                    {
                        x: [d_i * 1e9, d_o * 1e9],
                        y: [Q_sh / Q_a, Q_sh / Q_a],
                        mode: 'lines',
                        name: 'Selected Q_sh',
                        line: { color: 'blue' }
                    }
                ];

                const layout = {
                    title: 'DMA Operational Range',
                    xaxis: {
                        title: {
                            text: '$$Mobility diameter, D_{\\mathrm{m}} (nm)$$',
                            font: {
                                size: 14
                            }
                        },
                        type: 'log',
                        showgrid: true,
                        gridwidth: 1
                    },
                    yaxis: {
                        title: {
                            text: '$R_{\\mathrm{B}}$',
                            font: {
                                size: 14
                            }
                        },
                        type: 'log',
                        showgrid: true,
                        gridwidth: 1
                    },
                    showlegend: true
                };

                const config = {
                    mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_SVG'
                };

                Plotly.newPlot('plot', traces, layout, config);
                console.log('Calculation completed successfully');
                
            } catch (error) {
                console.error('Error in calculateDMA:', error);
                alert('An error occurred during calculation. Please check the console for details.');
            }
        }

        // Calculate initial plot when page loads
        document.addEventListener('DOMContentLoaded', calculateDMA);
    </script>
</body>
</html> 